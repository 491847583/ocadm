/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package keepalived

import (
	"fmt"
	"runtime"

	"github.com/pkg/errors"
	"k8s.io/kubernetes/cmd/kubeadm/app/cmd/options"
	initphases "k8s.io/kubernetes/cmd/kubeadm/app/cmd/phases/init"
	"k8s.io/kubernetes/cmd/kubeadm/app/cmd/phases/workflow"
	cmdutil "k8s.io/kubernetes/cmd/kubeadm/app/cmd/util"
	"k8s.io/kubernetes/pkg/util/normalizer"
)

var (
	keepalivedLocalExample = normalizer.Examples(`
	# Generates the static Pod manifest file for keepalived, functionally
	# equivalent to what is generated by kubeadm init.
	kubeadm init phase keepalived local

	# Generates the static Pod manifest file for keepalived using options
	# read from a configuration file.
	kubeadm init phase keepalived local --config config.yaml
	`)
)

// NewKeepalivedPhase creates a kubeadm workflow phase that implements handling of keepalived.
func NewKeepalivedPhase() workflow.Phase {
	phase := workflow.Phase{
		Name:  "keepalived",
		Short: "Generate static Pod manifest file for local keepalived",
		Long:  cmdutil.MacroCommandLongDescription,
		Phases: []workflow.Phase{
			newKeepalivedLocalSubPhase(),
		},
	}
	return phase
}

func newKeepalivedLocalSubPhase() workflow.Phase {
	phase := workflow.Phase{
		Name:         "local",
		Short:        "Generate the static Pod manifest file for a local, single-node local keepalived instance",
		Example:      keepalivedLocalExample,
		Run:          runKeepalivedPhaseLocal(),
		InheritFlags: getKeepalivedPhaseFlags(),
	}
	return phase
}

func getKeepalivedPhaseFlags() []string {
	flags := []string{
		options.CertificatesDir,
		options.CfgPath,
		options.ImageRepository,
	}
	return flags
}

func Trace(msg string) {
	pc := make([]uintptr, 15)
	n := runtime.Callers(2, pc)
	frames := runtime.CallersFrames(pc[:n])
	frame, _ := frames.Next()
	fmt.Printf("[ rexxer %s ] %s:%d %s\n", msg, frame.File, frame.Line, frame.Function)
}

func runKeepalivedPhaseLocal() func(c workflow.RunData) error {
	return func(c workflow.RunData) error {
		Trace("enter")
		data, ok := c.(initphases.InitData)
		if !ok {
			Trace("invalid data struct")
			return errors.New("keepalived phase invoked with an invalid data struct")
		}
		cfg := data.Cfg()
		fmt.Printf("[[runKeepalivedPhaseLocal]] cfg.Keepalived.Local: %+v\n", cfg)
		// Add keepalived static pod spec only if external keepalived is not configured
		Trace("END of runKeepalivedPhaseLocal")
		return nil
	}
}
